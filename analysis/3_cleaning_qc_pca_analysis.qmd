---
title: "RNAseq downstream analysis - data cleaning, QC, PCA analysis"
author: "Tu Hu"
date: "2023-06-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load package

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)
library(tidybulk)
library(tidySummarizedExperiment)
library(biomaRt)
library(ggplot2)
library(ggpubr)
```

## Prepare the data

### SummarizedExperiment

The `.rds` file was generated from the nextflow pipeline, which is already in the `SummarizedExperiment` object.

```{r summarizedexperiment data}
se <- readRDS("../data/salmon.merged.gene_counts.rds")
se
```

### Sample meta data

This dataset is rather small, thus I manually created the metadata.

```{r generate metadata}
metadata <-
  tibble(sample_name = colnames(se)) %>% 
  mutate(animal = sample_name %>% str_extract("[:alnum:]{1,6}"),
         sample_date =  sample_name %>% str_extract("[:digit:]{4}\\.[:digit:]{2}\\.[:digit:]{2}"),
         vacc = case_when(
           animal %in% c("CFL098", "CGB091", "CGB093", "CGB097", "CGB104") ~ "H107_CAF04_CpG",
           animal %in% c("CFL069", "CGA054", "CGB065", "CGB088", "CGC010") ~ "H107_CAF09c"
         ),
         timepoint = case_when(
           sample_date == "2019.06.24" ~ "pre", # pre-immunization
           sample_date == "2019.06.25" ~ "immu1", # day 1 after immunization 1
           sample_date == "2019.07.23" ~ "immu2" # day 1 after immunization 2
         ),
         timepoint = factor(timepoint, levels = c("pre", "immu1", "immu2")))
col_data <- 
  metadata %>% tibble::column_to_rownames("sample_name") %>% 
  DataFrame()
colData(se) <- col_data
```

To note, **H107_CAF04_CpG** is equivalent to **CAF10b**. **H107_CAF09c** is equivalent to **CAF09^hi^** . I kept them consistent in the figures and publication. But in my code, I did not harmonize them, in afraid of side-effects.

### Gene annotation data

I generated gene annotation data (`rowData` of the `SummarizedExperiment` object) by querying ensembl. I used `runonce::save_run` to save the query results, because the connection to Ensembl is not always stable.

```{r generate rowdata}
gene_data_Type <- 
  runonce::save_run(
    {
      ensembl <- useEnsembl(biomart = "genes", 
                            dataset = "mfascicularis_gene_ensembl")
      gene_data <- getBM(
        attributes = c("ensembl_gene_id", "description", "gene_biotype"), 
        mart = ensembl)
      
      gene_data_Type <- 
        rowData(se) %>% as_tibble(rownames = "rowname") %>% 
        left_join(gene_data, by = c("gene_id" = "ensembl_gene_id"))
      
      gene_data_Type
    }, "../data/gene_data_Type.rds"
  )
rowData(se) <- gene_data_Type %>% tibble::column_to_rownames() %>% DataFrame()
```

I kept only protein coding genes for downstream analysis.

```{r generate se_pcoding}
se_pcoding <- se[rowData(se)$gene_biotype == "protein_coding", ] # protein coding gene
```

# PCA (QC)

```{r detect abundant and scale counts, message=FALSE, warning=FALSE}
se_pcoding_scale_abundant <- 
  se_pcoding %>% 
  identify_abundant() %>% 
  scale_abundance()

rownames(se_pcoding_scale_abundant) <- 
  rowData(se_pcoding_scale_abundant)$gene_name
```

We used this ugly PCA plot to detect outliers.

Two outlier samples were detected. We also checked the QC report generated by multiqc from the nextflow pipeline. These two samples showed distorted distribution of GC% content. After discussing with the sequencing service provider (Azenta Genewiz), we hypothesized that these two samples had incomplete depletion of globulin. Thus, we removed these two outlier samples for downstream analysis.

```{r pca, message=FALSE, warning=FALSE}
pca <- 
  se_pcoding_scale_abundant %>% reduce_dimensions(method = "PCA")

pca %>% pivot_sample() %>% 
  ggscatter(x = "PC1", y = "PC2", label = ".sample")
```

```{r PCA after removing two samples, message=FALSE, warning=FALSE}
se_pcoding_scale_abundant_filtS <- 
  se_pcoding_scale_abundant[, !colnames(se) %in% c("CGB097.2019.06.24", "CGB065.2019.06.24")]
```

```{r save rds, eval=FALSE}
saveRDS(se_pcoding_scale_abundant_filtS, "../data/se_pcoding_scale_abundant_filtS.rds")
```

```{r}
pca_filtS <- 
  se_pcoding_scale_abundant_filtS %>% 
  reduce_dimensions(method = "PCA", top = 1500)

pca_filtS %>% pivot_sample() %>% 
  ggscatter(x = "PC1", y = "PC2", label = ".sample")
```

## PCA (Story-telling)

### Visualization (draft)

This was our first draft of visualization. The information was too complicated to comprehend. Thus, we fancied a better visualization below.

```{r Calculate var% explained}
pca_data <- attr(pca_filtS, "internals")$PCA
variance_explained <- pca_data$sdev^2
proportion_variance_explained <- variance_explained / sum(variance_explained)
```

```{r}
pca_filtS %>% pivot_sample() %>%
  ggplot(aes(x = PC1, y = PC2, color = timepoint, shape = vacc)) +
  geom_point() +
  coord_equal(ratio = 1) +
  theme_bw() +
  xlab(paste0("PC1 (", sprintf("%.1f%%", proportion_variance_explained[1] * 100), ")")) +
  ylab(paste0("PC2 (", sprintf("%.1f%%", proportion_variance_explained[2] * 100), ")")) +
  theme(aspect.ratio=1) +
  scale_shape_manual(values = c(1, 16, 17))
```

### Visualization (publication)

```{r}
g_immune1 <- 
  pca_filtS %>% pivot_sample() %>%
  filter(timepoint != "immu2") %>% 
  mutate(timepoint_vacc = paste(timepoint, vacc),
         timepoint_vacc = case_when(timepoint == "pre" ~ "pre",
                                    .default = timepoint_vacc)) %>% 
  ggplot(aes(x = PC1, y = PC2, color = timepoint_vacc, fill = timepoint_vacc)) +
  geom_point() +
  stat_ellipse(type = "t") +
  coord_equal(ratio = 1, xlim = c(-60, 70), ylim = c(-45, 55)) +
  theme_bw() +
  theme(aspect.ratio=1, legend.position = "none") +
  scale_shape_manual(values = c(1, 16, 17)) +
  scale_color_manual(values = c("red", "blue", "black")) +
  xlab(paste0("PC1 (", sprintf("%.1f%%", proportion_variance_explained[1] * 100), ")")) +
  ylab(paste0("PC2 (", sprintf("%.1f%%", proportion_variance_explained[2] * 100), ")")) 

g_immune1

ggsave("../data/figure/pca_immune1.png", g_immune1, dpi = 500, 
       width = 5, height = 5, scale = 0.8)

```

```{r}
g_immune2 <- 
pca_filtS %>% pivot_sample() %>%
  filter(timepoint != "immu1") %>% 
  mutate(timepoint_vacc = paste(timepoint, vacc),
         timepoint_vacc = case_when(timepoint == "pre" ~ "pre",
                                    .default = timepoint_vacc)) %>% 
  ggplot(aes(x = PC1, y = PC2, color = timepoint_vacc, fill = timepoint_vacc)) +
  geom_point() +
  stat_ellipse(type = "t") +
  coord_equal(ratio = 1, xlim = c(-60, 70), ylim = c(-45, 55)) +
  theme_bw() +
  theme(aspect.ratio=1, legend.position = "none") +
  scale_shape_manual(values = c(1, 16, 17)) +
  scale_color_manual(values = c("red", "blue", "black")) +
  xlab(paste0("PC1 (", sprintf("%.1f%%", proportion_variance_explained[1] * 100), ")")) +
  ylab(paste0("PC2 (", sprintf("%.1f%%", proportion_variance_explained[2] * 100), ")"))

g_immune2

ggsave("../data/figure/pca_immune2.png", g_immune2, dpi = 500, 
       width = 5, height = 5, scale = 0.8)
```
